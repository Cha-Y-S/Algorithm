# [달이 차오른다, 가자.](https://www.acmicpc.net/problem/1194)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 10325 | 3943 | 2619      | 35.173%   |

</div>

### 문제

지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다.

민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다.

하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다.

영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다.

민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미로는 다음과 같이 구성되어져있다.

  - 빈 칸: 언제나 이동할 수 있다. ('.')

  - 벽: 절대 이동할 수 없다. ('#')

  - 열쇠: 언제나 이동할 수 있다. 이 곳에 처음 들어가면 열쇠를 집는다. ('a', 'b', 'c', 'd', 'e', 'f')

  - 문: 대응하는 열쇠가 있을 때만 이동할 수 있다. ('A', 'B', 'C', 'D', 'E', 'F')

  - 민식이의 현재 위치: 빈 곳이고, 민식이가 현재 서 있는 곳이다. ('0')

  - 출구: 달이 차오르기 때문에, 민식이가 가야하는 곳이다. 이 곳에 오면 미로를 탈출한다. ('1')

달이 차오르는 기회를 놓치지 않기 위해서, 미로를 탈출하려고 한다. 한 번의 움직임은 현재 위치에서 수평이나 수직으로 한 칸 이동하는 것이다.

민식이가 미로를 탈출하는데 걸리는 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

---

### 입력

첫째 줄에 미로의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 50) 둘째 줄부터 N개의 줄에 미로의 모양이 주어진다. 같은 타입의 열쇠가 여러 개 있을 수 있고, 문도 마찬가지이다. 그리고, 문에 대응하는 열쇠가 없을 수도 있다. '0'은 한 개, '1'은 적어도 한 개 있다. 열쇠는 여러 번 사용할 수 있다.

---

### 출력

첫째 줄에 민식이가 미로를 탈출하는데 드는 이동 횟수의 최솟값을 출력한다. 만약 민식이가 미로를 탈출 할 수 없으면, -1을 출력한다.

---

### 예제 입력

| 예제 입력1          | 예제 출력1 |
| :------------------ | :--------- |
| `1 7`<br/>`f0.F..1` | 7          |

| 예제 입력2                                                        | 예제 출력2 |
| :---------------------------------------------------------------- | :--------- |
| `5 5`<br/>`....1`<br/>`#1###`<br/>`.1.#0`<br/>`....A`<br/>`.1.#.` | -1         |

| 예제 입력3                                                                                                     | 예제 출력3 |
| :------------------------------------------------------------------------------------------------------------- | :--------- |
| `7 8`<br/>`a#c#eF.1`<br/>`.#.#.#..`<br/>`.#B#D###`<br/>`0....F.1`<br/>`C#E#A###`<br/>`.#.#.#..`<br/>`d#f#bF.1` | 55         |

| 예제 입력4                             | 예제 출력4 |
| :------------------------------------- | :--------- |
| `3 4`<br/>`1..0`<br/>`###.`<br/>`1...` | 3          |

| 예제 입력5                                | 예제 출력5 |
| :---------------------------------------- | :--------- |
| `3 5`<br/>`..0..`<br/>`.###.`<br/>`..1.A` | 6          |

| 예제 입력6                                            | 예제 출력6 |
| :---------------------------------------------------- | :--------- |
| `4 5`<br/>`0....`<br/>`.#B#A`<br/>`.#.#.`<br/>`b#a#1` | 19         |

| 예제 입력7               | 예제 출력7 |
| :----------------------- | :--------- |
| `1 11`<br/>`c.0.C.C.C.1` | 12         |

| 예제 입력8                                   | 예제 출력8 |
| :------------------------------------------- | :--------- |
| `3 6`<br/>`###...`<br/>`#0A.1a`<br/>`###...` | -1         |

---

### 문제 접근

  - `BitMasking`을 사용하는 `BFS` 문제

    - 기본적인 `BFS`형태에 `BitMasking`을 활용하여 조건에 따라 `queue`에 다음 지점 추가

  - `a` ~ `f` 의 키값과 `A` ~ `F`의 문 값을 각각 6비트의 값으로 매핑

    - <table>
        <tr>
          <td>a, A</td>
          <td>000001</td>
        </tr>
        <tr>
          <td>b, B</td>
          <td>000010</td>
        </tr>
        <tr>
          <td>c, C</td>
          <td>000100</td>
        </tr>
        <tr>
          <td>d, D</td>
          <td>001000</td>
        </tr>
        <tr>
          <td>e, E</td>
          <td>010000</td>
        </tr>
        <tr>
          <td>f, F</td>
          <td>100000</td>
        </tr>    
      </table>

  - `BFS` 수행하며 매 순회 시 마다 `queue`에는 `{{x, y}, {cnt, key}}`값을 push하며, `cnt`는 이동 횟수, `key`는 현재 가지고 있는 키를 의미

  - 매 순회 시 마다 3가지 조건 검사

    - 다음 좌표점이 이동 가능한 지점(`.` or `1`)인 경우 `queue`에 push

    - 다음 좌표점이 `a` ~ `f`의 값, `키`라면 현재 키 상태에 or 연산을 통해 가지고 있는 키를 추가 후 push

    - 다음 좌표점이 `A` ~ `F`의 값, `문`이라면 현재 가지고 있는 키와 문을 검사하여 문을 통과 가능한지 확인한 후, 통과 가능하면 push

  - `visited`는 3차원으로 구성하여 1차원과 2차원은 각각 `x`와 `y`를 의미하며, 3차원은 현재 들고있는 `key` 상태를 의미함

  - `BFS` 수행 도중 `1` 지점에 도달하면 `cnt`값을 return하고, `queue`가 빌 때까지 `1`을 만나지 못하여 반복문을 탈출하면 `-1` 반환