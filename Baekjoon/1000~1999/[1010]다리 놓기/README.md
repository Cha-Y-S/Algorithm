# [다리 놓기](https://www.acmicpc.net/problem/1010)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 0.5 초    | 128 MB      | 44942 | 20537 | 16787     | 48.167%   |

</div>

### 문제

재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)

재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.

<img src="https://www.acmicpc.net/upload/201003/pic1.JPG" width="329" height="353" />

---

### 입력

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.

---

### 출력

각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.

---

### 예제 입력

| 예제 입력1                  | 예제 출력1           |
| :-------------------------- | :------------------- |
| 3<br/>2 2<br/>1 5<br/>13 29 | 1<br/>5<br/>67863915 |

---

### 문제 접근

  - `DP` 문제

  - `N`과 `M`의 값에 따라 놓을 수 있는 다리 수가 달라지기 때문에 `dp` 벡터를 2차원으로 선언

  - `N`이 1인 경우 다리를 놓을 수 있는 경우의 수는 `M`의 개수로 정해짐(경우의 수 = `M`)

  - `N`이 2 이상인 경우, `dp[i][j]`의 값은 `dp[i-1][i-1]`부터 `dp[i-1][j-1]`까지의 합으로 점화식을 구할 수 있음

  - 따라서 3개의 반복문을 활용하여 문제 해결

    - 데이터의 개수가 `N=29`, `M=29`로 작기 때문에 가능

---

### 다른 사람의 풀이

```cpp
#include <iostream>
#include <cmath>
#include <string>
#include <algorithm>

using namespace std;

int main(void)
{
  int N, M, i, j, T;
  int DP[33][33] = { 0 };

  cin >> T;
  while(T--)
  {
    cin >> N >> M;

    for(i = 1; i <= M; i++)
    {
      DP[1][i] = i;
    }

    for(i = 2; i<= N; i++)
    {
      for(j = 2; j <=M; j++)
      {
        DP[i][j] = DP[i-1][j-1] + DP[i][j-1];
      }
    }
    cout << DP[N][M] << endl;
  }
}
```

  - 기존 세워둔 점화식인 `dp[i][j] = sum(dp[i-1][i-1], dp[i-1][j-1])`에서 `dp[i-1][i-1]`부터 `dp[i-1][j-2]`까지의 값은 `dp[i][j-1]`을 구하는 식과 동일

  - 따라서, 기존 점화식을 `dp[i][j] = dp[i-1][j-1] + dp[i][j-1]`로 치환하면, 3중 반복문을 2중 반복문으로 줄일 수 있음