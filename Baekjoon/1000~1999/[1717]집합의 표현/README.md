# [집합의 표현](https://www.acmicpc.net/problem/1717)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 2 초      | 128 MB      | 50855 | 16031 | 9689      | 28.454%   |

</div>

### 문제

초기에 {0}, {1}, {2}, ... {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.

집합을 표현하는 프로그램을 작성하시오.

---

### 입력

첫째 줄에 n(1 ≤ n ≤ 1,000,000), m(1 ≤ m ≤ 100,000)이 주어진다. m은 입력으로 주어지는 연산의 개수이다. 다음 m개의 줄에는 각각의 연산이 주어진다. 합집합은 0 a b의 형태로 입력이 주어진다. 이는 a가 포함되어 있는 집합과, b가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 1 a b의 형태로 입력이 주어진다. 이는 a와 b가 같은 집합에 포함되어 있는지를 확인하는 연산이다. a와 b는 n 이하의 자연수 또는 0이며 같을 수도 있다.

---

### 출력

1로 시작하는 입력에 대해서 한 줄에 하나씩 YES/NO로 결과를 출력한다. (yes/no 를 출력해도 된다)

---

### 예제 입력

| 예제 입력1                                                                          | 예제 출력1        |
| :---------------------------------------------------------------------------------- | :---------------- |
| 7 8<br/>0 1 3<br/>1 1 7<br/>0 7 6<br/>1 7 1<br/>0 3 7<br/>0 4 2<br/>0 1 1<br/>1 1 1 | NO<br/>NO<br/>YES |

---

### 문제 접근

  - 서로소 집합의 `union find` 문제

  - `query`가 `0`인 경우 입력받은 두 수를 `union`

    ```cpp
    void union_set(int a, int b){
      // 입력받은 두 수의 루트 노드를 찾음
      // 단 한번도 union 연산이 수행되지 않은 트리의 경우 각 노드의 루트는 자기 자신으로 초기화 되어 있음
      int sa = find_set(a);
      int sb = find_set(b);

      // 두 수의 루트 노드가 같은 경우 종료
      if(sa == sb) return;

      // 루트 노드가 다른 경우 두 수의 루트 노드를 같게 함
      ds[sb] = sa;
    }
    ```

  - `query`가 `1`인 경우 입력받은 두 수를 `find`하여 두 수의 루트 노드가 같은 경우 `YES` 출력, 아닌 경우 `NO` 출력

    ```cpp
    int find_set(int a){
      // 루트 노드가 자기 자신인 경우 자기 자신을 반환
      if(arr[a] == a) return a;
      
      // 자기 자신이 아닌 경우 자신의 루트 노드를 찾아 반환
      return find_set(a);
    }

    int optimized_find_set(int a){
      if(arr[a] == a) return a;

      // 루트 노드를 다시 잡아줌으로써 다음 find 연산 시 루트노드를 찾는 경로가 최적화됨
      return arr[a] = find_set(a);
    }
    ```