# [미로 탐색](https://www.acmicpc.net/problem/2178)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------: | :---------: | :---: | :---: | :-------: | :-------: |
|   1 초    |   192 MB    | 94417 | 37659 |   24014   |  38.574%  |

</div>

### 문제

N×M크기의 배열로 표현되는 미로가 있다.

<div>
  <table>
    <tr>
      <td align = center>1</td>
      <td align = center>0</td>
      <td align = center>1</td>
      <td align = center>1</td>
      <td align = center>1</td>
      <td align = center>1</td>
    </tr>
    <tr>
      <td align = center>1</td>
      <td align = center>0</td>
      <td align = center>1</td>
      <td align = center>0</td>
      <td align = center>1</td>
      <td align = center>0</td>
    </tr>
    <tr>
      <td align = center>1</td>
      <td align = center>0</td>
      <td align = center>1</td>
      <td align = center>0</td>
      <td align = center>1</td>
      <td align = center>1</td>
      <tr>
      <td align = center>1</td>
      <td align = center>1</td>
      <td align = center>1</td>
      <td align = center>0</td>
      <td align = center>1</td>
      <td align = center>1</td>
    </tr>
  </table>
</div>

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

---

### 입력

첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 **붙어서** 입력으로 주어진다.

---

### 출력

첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

---

### 예제 입력

|                   예제 입력1                    | 예제 출력1 |
| :---------------------------------------------: | :--------: |
| 4 6<br/>101111<br/>101010<br/>101011<br/>111011 |     15     |

|                   예제 입력2                    | 예제 출력2 |
| :---------------------------------------------: | :--------: |
| 4 6<br/>110110<br/>110110<br/>111111<br/>111101 |     9      |

|                            예제 입력3                            | 예제 출력3 |
| :--------------------------------------------------------------: | :--------: |
| 2 25<br/>1011101110111011101110111<br/>1110111011101110111011101 |     38     |

|                                       예제 입력4                                        | 예제 출력4 |
| :-------------------------------------------------------------------------------------: | :--------: |
| 7 7<br/>1011111<br/>1110001<br/>1000001<br/>1000001<br/>1000001<br/>1000001<br/>1111111 |     13     |

---

### 문제 접근

  - 그래프 내 최단 거리를 구하는 것이므로 `Breadth First Search`

  - 입력값 기반 `matrix` 초기화

  - `matrix`와 같은 크기의 `visited` 초기화

    - `visited`는 이미 방문을 했는지에 대한 검사와 동시에 해당 시작좌표로부터 해당 좌표까지 도달하는데 필요한 `step` 수를 저장하고 있음

  - `queue<pair<int, int>>`사용

    - `queue`에는 검사 대상 좌표가 들어있음

  - 검사 대상 좌표를 기준으로 4방향 검사(북, 동, 남, 서) / **시계방향**

    - `vector<> dir`에 `북, 동, 남, 서`에 대한 정보 저장

      ```cpp
      vector<pair<int, int>> dir = {make_pair(0, -1), make_pair(1, 0), make_pair(0, 1), make_pair(-1, 0)};
      ```

      |       |  북   |  동   |  남   |  서   |
      | :---: | :---: | :---: | :---: | :---: |
      |   x   |   0   |   1   |   0   |  -1   |
      |   y   |   1   |   0   |  -1   |   0   |
    
  - 4방면 중 `matrix`를 벗어난 경우 pass

  - `matrix`를 벗어나지 않은 경우 다음 로직 수행

    - 해당 좌표를 방문한 적이 없고 벽이 아닌 경우 push

    - 이때, 해당 좌표까지의 `total step`은 현재 좌표까지의 `total step + 1`

      ```cpp
      visited[nx][ny] = visited[cx][cy] + 1;
      ```

  - 목표 지점까지의 최소 단계 수는 `visited[dx][dy]`