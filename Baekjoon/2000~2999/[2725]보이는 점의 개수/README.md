# [보이는 점의 개수](https://www.acmicpc.net/problem/2725)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 128 MB      | 2249 | 1187 | 940       | 53.745%   |

</div>

### 문제

(0,0)에서 보이는 (x,y)의 개수를 구하려고 한다.(x,y >= 0, 정수)

(0,0)에서 (x,y)가 보이려면 (0,0)과 (x,y)를 연결하는 직선이 다른 점을 통과하지 않아야 한다. 예를 들어 (4,2)는 (0,0)에서 보이지 않는다. 그 이유는 (0,0)과 (4,2)를 연결하는 직선이 (2,1)을 통과하기 때문이다. 아래 그림은 0 <= x,y<=5인 경우에 (0,0)에서 보이는 점의 개수이다. 단, (0,0)은 계산하지 않는다.

<img src="https://www.acmicpc.net/upload/images/qqwq.png" width="221px" height="208px" />

N이 주어졌을 때, 원점에서 보이는 (x,y) 좌표의 개수를 출력하시오. (0 <= x,y <= N)

---

### 입력

첫째 줄에 테스트 케이스의 개수 C(1<=C<=1,000)가 주어진다. 각 테스트 케이스는 자연수 N(1<=N<=1,000) 하나로 이루어져 있고, 한 줄에 하나씩 주어진다.

---

### 출력

각 테스트 케이스에 대해 한 줄에 하나씩 (0,0)에서 보이는 점(x,y)의 개수를 출력한다.

---

### 예제 입력

| 예제 입력1                  | 예제 출력1                |
| :-------------------------- | :------------------------ |
| 4<br/>2<br/>4<br/>5<br/>231 | 5<br/>13<br/>21<br/>32549 |

---

### 문제 접근

1. `(x, y)`가 다른 점을 포함하지 않고 (0, 0)에서 보이려면 `x, y`가 서로소여야 함

   - 서로소: 두 수의 최대공약수가 1인 수

2. `N`까지의 보이는 `(x, y)`를 저장할 벡터 `coprime_count` 선언

   - `coprime_count[1]`의 값은 3으로 초기화

3. 테스트케이스를 입력받기 전, 2 ~ 1000까지 반복하며 기준 수 `i` 설정

4. 1 ~ `i`까지 순회하며 `i, j`의 최대공약수를 구하고, 최대공약수가 1인 경우 2를 카운트함(<i, j>의 경우와 <j, i>의 경우)

5. `coprime_count[i]`의 값을 `coprime_count[i-1] + cnt`의 값으로 초기화

6. 테스트케이스를 하나씩 입력받으면서 `coprime_count[N]`의 값 출력
