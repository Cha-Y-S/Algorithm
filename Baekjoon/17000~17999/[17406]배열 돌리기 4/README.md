# [배열 돌리기 4](https://www.acmicpc.net/problem/17406)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초      | 512 MB      | 14817 | 6141 | 4213      | 38.549%   |

</div>

### 문제

크기가 N×M 크기인 배열 A가 있을때, 배열 A의 값은 각 행에 있는 모든 수의 합 중 최솟값을 의미한다. 배열 A가 아래와 같은 경우 1행의 합은 6, 2행의 합은 4, 3행의 합은 15이다. 따라서, 배열 A의 값은 4이다.

<pre>1 2 3
2 1 1
4 5 6</pre>

배열은 회전 연산을 수행할 수 있다. 회전 연산은 세 정수 (r, c, s)로 이루어져 있고, 가장 왼쪽 윗 칸이 (r-s, c-s), 가장 오른쪽 아랫 칸이 (r+s, c+s)인 정사각형을 시계 방향으로 한 칸씩 돌린다는 의미이다. 배열의 칸 (r, c)는 r행 c열을 의미한다.

예를 들어, 배열 A의 크기가 6×6이고, 회전 연산이 (3, 4, 2)인 경우에는 아래 그림과 같이 회전하게 된다.

<pre>A[1][1]   A[1][2] → A[1][3] → A[1][4] → A[1][5] → A[1][6]
             ↑                                       ↓
A[2][1]   A[2][2]   A[2][3] → A[2][4] → A[2][5]   A[2][6]
             ↑         ↑                   ↓         ↓
A[3][1]   A[3][2]   A[3][3]   A[3][4]   A[3][5]   A[3][6]
             ↑         ↑                   ↓         ↓
A[4][1]   A[4][2]   A[4][3] ← A[4][4] ← A[4][5]   A[4][6]
             ↑                                       ↓
A[5][1]   A[5][2] ← A[5][3] ← A[5][4] ← A[5][5] ← A[5][6]

A[6][1]   A[6][2]   A[6][3]   A[6][4]   A[6][5]   A[6][6]</pre>

회전 연산이 두 개 이상이면, 연산을 수행한 순서에 따라 최종 배열이 다르다.

다음은 배열 A의 크기가 5×6이고, 회전 연산이 (3, 4, 2), (4, 2, 1)인 경우의 예시이다.

<table align=center>
  <tr>
    <td align=center>
      <pre align=center>1 2 3 2 5 6
3 8 7 2 1 3
8 2 3 1 4 5
3 4 5 1 1 1
9 3 2 1 4 3</pre>
    </td>
    <td align=center>
      <pre align=center>1 8 2 3 2 5
3 2 3 7 2 6
8 4 5 1 1 3
3 3 1 1 4 5
9 2 1 4 3 1</pre>
    </td>
    <td align=center>
      <pre align=center>1 8 2 3 2 5
3 2 3 7 2 6
3 8 4 1 1 3
9 3 5 1 4 5
2 1 1 4 3 1</pre>
    </td>
  </tr>
  <tr>
    <td align=center>배열 A</td>
    <td align=center>(3, 4, 2) 연산 수행 후</td>
    <td align=center>(4, 2, 1) 연산 수행 후</td>
  </tr>
  <tr>
    <td align=center>
      <pre align=center>1 2 3 2 5 6
3 8 7 2 1 3
8 2 3 1 4 5
3 4 5 1 1 1
9 3 2 1 4 3</pre>
    </td>
    <td align=center>
      <pre align=center>1 2 3 2 5 6
3 8 7 2 1 3
3 8 2 1 4 5
9 4 3 1 1 1
3 2 5 1 4 3</pre>
    </td>
    <td align=center>
      <pre align=center>1 8 2 3 2 5
3 8 2 7 2 6
3 4 3 1 1 3
9 2 1 1 4 5
3 5 1 4 3 1</pre>
    </td>
  </tr>
  <tr>
    <td align=center>배열 A</td>
    <td align=center>(4, 2, 1) 연산 수행 후</td>
    <td align=center>(3, 4, 2) 연산 수행 후</td>
  </tr>
</table>

---

### 입력

배열 A의 값의 최솟값을 출력한다.

---

### 출력

- 3 ≤ N, M ≤ 50

- 1 ≤ K ≤ 6

- 1 ≤ A[i][j] ≤ 100

- 1 ≤ s

- 1 ≤ r-s < r < r+s ≤ N

- 1 ≤ c-s < c < c+s ≤ M

---

### 예제 입력

| 예제 입력1                                                                                                | 예제 출력1 |
| :-------------------------------------------------------------------------------------------------------- | :--------- |
| 5 6 2<br/>1 2 3 2 5 6<br/>3 8 7 2 1 3<br/>8 2 3 1 4 5<br/>3 4 5 1 1 1<br/>9 3 2 1 4 3<br/>3 4 2<br/>4 2 1 | 12         |

---

### 문제 접근

- operation을 저장하기 위한 Struct 구성

1. Back-trackingd을 사용해 Operation의 순서 정의

2. rotate 수행 전 원본 matrix를 matrix 복사본에 옮김

3. 정의된 Operation의 순서대로 배열을 돌림

   2-1. 시작점의 값을 저장

   2-2. 시작점의 값을 `현재 위치 + dirs[dir_idx]`의 값으로 변경

   2-3. Scope을 벗어나지 않을 때 까지 위 과정 반복하며, Scope을 벗어나는 경우 `(dir_idx + 1) % 4`로 `dir_idx` 조정

   2-4. 다음 위치의 값이 시작 지점이 되기 전까지 반복

   2-5. 다음 위치가 시작 지점인 경우, 왼쪽 상단의 범위를 + 1, 우측 하단의 범위를 - 1하여 2-1 ~ 2.4 과정 반복

   2-6. 왼쪽 상단의 범위가 오른쪽 하단의 범위보다 작을 때까지 반복

4. rotate가 종료된 후 배열의 값을 계산
