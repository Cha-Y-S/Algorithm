# [오민식의 고민](https://www.acmicpc.net/problem/1219)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 8459 | 1554 | 869       | 15.593%   |

</div>

### 문제

오민식은 세일즈맨이다. 오민식의 회사 사장님은 오민식에게 물건을 최대한 많이 팔아서 최대 이윤을 남기라고 했다.

오민식은 고민에 빠졌다.

어떻게 하면 최대 이윤을 낼 수 있을까?

이 나라에는 N개의 도시가 있다. 도시는 0번부터 N-1번까지 번호 매겨져 있다. 오민식의 여행은 A도시에서 시작해서 B도시에서 끝난다.

오민식이 이용할 수 있는 교통수단은 여러 가지가 있다. 오민식은 모든 교통수단의 출발 도시와 도착 도시를 알고 있고, 비용도 알고 있다. 게다가, 오민식은 각각의 도시를 방문할 때마다 벌 수 있는 돈을 알고있다. 이 값은 도시마다 다르며, 액수는 고정되어있다. 또, 도시를 방문할 때마다 그 돈을 벌게 된다.

오민식은 도착 도시에 도착할 때, 가지고 있는 돈의 액수를 최대로 하려고 한다. 이 최댓값을 구하는 프로그램을 작성하시오.

오민식이 버는 돈보다 쓰는 돈이 많다면, 도착 도시에 도착할 때 가지고 있는 돈의 액수가 음수가 될 수도 있다. 또, 같은 도시를 여러 번 방문할 수 있으며, 그 도시를 방문할 때마다 돈을 벌게 된다. 모든 교통 수단은 입력으로 주어진 방향으로만 이용할 수 있으며, 여러 번 이용할 수도 있다.

---

### 입력

첫째 줄에 도시의 수 N과 시작 도시, 도착 도시 그리고 교통 수단의 개수 M이 주어진다. 둘째 줄부터 M개의 줄에는 교통 수단의 정보가 주어진다. 교통 수단의 정보는 “시작 끝 가격”과 같은 형식이다. 마지막 줄에는 오민식이 각 도시에서 벌 수 있는 돈의 최댓값이 0번 도시부터 차례대로 주어진다.

N과 M은 50보다 작거나 같고, 돈의 최댓값과 교통 수단의 가격은 1,000,000보다 작거나 같은 음이 아닌 정수이다.

---

### 출력

첫째 줄에 도착 도시에 도착할 때, 가지고 있는 돈의 액수의 최댓값을 출력한다. 만약 오민식이 도착 도시에 도착하는 것이 불가능할 때는 "gg"를 출력한다. 그리고, 오민식이 도착 도시에 도착했을 때 돈을 무한히 많이 가지고 있을 수 있다면 "Gee"를 출력한다.

---

### 예제 입력

| 예제 입력1                                                                                           | 예제 출력1 |
| :--------------------------------------------------------------------------------------------------- | :--------- |
| 5 0 4 7<br/>0 1 13<br/>1 2 17<br/>2 4 20<br/>0 3 22<br/>1 3 4747<br/>2 0 10<br/>3 4 10<br/>0 0 0 0 0 | -32        |

| 예제 입력2                                                                        | 예제 출력2 |
| :-------------------------------------------------------------------------------- | :--------- |
| 5 0 4 5<br/>0 1 10<br/>1 2 10<br/>2 3 10<br/>3 1 10<br/>2 4 10<br/>0 10 10 110 10 | Gee        |

| 예제 입력3                                                   | 예제 출력3 |
| :----------------------------------------------------------- | :--------- |
| 3 0 2 3<br/>0 1 10<br/>1 0 10<br/>2 1 10<br/>1000 1000 47000 | gg         |

| 예제 입력4                                | 예제 출력4 |
| :---------------------------------------- | :--------- |
| 2 0 1 2<br/>0 1 1000<br/>1 1 10<br/>11 11 | Gee        |

| 예제 입력5               | 예제 출력5 |
| :----------------------- | :--------- |
| 1 0 0 1<br/>0 0 10<br/>7 | 7          |

| 예제 입력6                                                                                                  | 예제 출력6 |
| :---------------------------------------------------------------------------------------------------------- | :--------- |
| 5 0 4 7<br/>0 1 13<br/>1 2 17<br/>2 4 20<br/>0 3 22<br/>1 3 4747<br/>2 0 10<br/>3 4 10<br/>8 10 20 1 100000 | 99988      |

---

### 문제 접근

  - `벨만 포드` 알고리즘을 요구하는 문제

  - 문제의 입력방식을 살짝 바꾸어 교통 수단의 이용 가격은 양의 가중치로 유지하고 도시에서 버는 돈은 음수로 변경

    - `벨만 포드` 알고리즘이 최대 경로를 찾는 것이기 때문에, 양의 가중치가 최소가 되어야 하기 때문

  - 벨만 포드를 수행 후 음의 사이클이 존재하는지 확인하는 과정에 음의 사이클로부터 목표 정점까지 도달 가능한 경로가 있는지 추가 확인

    - `DFS`를 통해 목표 정점까지 도달 가능한지 확인

    - 음의 사이클로부터 목표 정점까지 도달 가능하면 `Gee` 출력

    - 음의 사이클이 존재하지만 목표 정점까지 도달 가능하지 않으면 `gg` 출력

  - 벨만 포드 수행 후 `dist[E]`의 값은 임의로 음의 값으로 변경한 값이기 때문에 출력 전에 `-1`을 곱하여 출력 필요

    - `dist`의 경우 `int`형의 범위를 넘어서는 입력이 주어질 수 있으므로 `long long`으로 선언해야 함