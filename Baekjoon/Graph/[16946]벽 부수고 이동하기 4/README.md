# [벽 부수고 이동하기 4](https://www.acmicpc.net/problem/16946)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 512 MB      | 8245 | 2314 | 1616      | 25.381%   |

</div>

### 문제

N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.

각각의 벽에 대해서 다음을 구해보려고 한다.

  - 벽을 부수고 이동할 수 있는 곳으로 변경한다.

  - 그 위치에서 이동할 수 있는 칸의 개수를 세어본다.

한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

---

### 입력

첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.

---

### 출력

맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.

---

### 예제 입력

| 예제 입력1                  | 예제 출력1          |
| :-------------------------- | :------------------ |
| 3 3<br/>101<br/>010<br/>101 | 303<br/>050<br/>303 |

| 예제 입력2                                  | 예제 출력2                          |
| :------------------------------------------ | :---------------------------------- |
| 4 5<br/>11001<br/>00111<br/>01010<br/>10101 | 46003<br/>00732<br/>06040<br/>50403 |

---

### 문제 접근

  - `matrix`: 입력받은 map을 저장하고 후에 정답 map이 되는 2차원 벡터

  - `numbering`: 0을 기준으로 하는 각 클러스터의 인덱스 정보를 가지는 2차원 벡터

  - `visited`: 0을 기준으로 하는 각 클러스터를 찾을 때 사용되는 2차원 벡터

  - `v`: 각 클러스터의 인덱스당 연결되어있는 0의 개수를 저장하는 1차원 벡터

  - 먼저 `BFS`를 수행하면서 0을 기준으로 하는 각 클러스터에 대해 인덱싱을 한 후 클러스터별 0의 개수를 `v`에 저장

  - `matrix`를 순회하며 해당 좌표점의 값이 1인 경우, 해당 좌표점을 기준으로 4방향을 검사하며 새로운 좌표점이 0이고 해당 좌표점에 대한 클러스터의 인덱스 값이 `set`에 없는 경우 인덱스 정보를 `set`에 추가

  - `set`에 추가된 인덱스 정보에 따라 `matrix` 기준 좌표점에 인덱스에 해당하는 `v`를 참조하여 기존 `matrix`값에 주변 0의 개수 추가

  - `matrix` 출력