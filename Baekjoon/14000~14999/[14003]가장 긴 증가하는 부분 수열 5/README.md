# [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/14003)

<div align = center>

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 3 초      | 512 MB      | 16033 | 5303 | 3816      | 34.939%   |

</div>

### 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

---

### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 A<sub>i</sub>가 주어진다. (-1,000,000,000 ≤ A<sub>i</sub> ≤ 1,000,000,000)

---

### 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.

---

### 예제 입력

| 예제 입력1              | 예제 출력1        |
| :---------------------- | :---------------- |
| 6<br/>10 20 10 30 20 50 | 4<br/>10 20 30 50 |

---

### 문제 접근

  - 이분 탐색 문제

  - [가장 긴 증가하는 부분 수열 3](https://www.acmicpc.net/problem/12738)과 같이 먼저 부분 수열의 최대 길이를 구함

    - 단, 최대 길이를 구하는 과정에서 구해지는 입력 수열 각 값이 부분 수열에 위치할 경우 어느 인덱스에 위치하는지 `seq`에 저장

    - `lis`: 부분 수열의 최대 길이를 구하기 위한 임시 수열

  - `target`을 `lis.size() - 1`로 잡고, `seq`를 역순회하면서 `target`과 `seq[i]`의 값이 같은 경우 `res[target]`위치에 `A[i]`의 값을 넣음

    - 입력 수열 값들 중 어떤 값들이 가장 긴 증가하는 부분 수열에 합당한 수인지 구하는 과정

    - `lis`는 부분 수열의 길이는 구할 수 있지만, 길이를 구하는 과정에서 입력 수열의 순서가 꼬이는 문제가 발생하기 때문에 해당 과정 필요


