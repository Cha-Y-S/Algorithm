# [2개 이하로 다른 비트](https://programmers.co.kr/learn/courses/30/lessons/77885) - 월간 코드 챌린지 시즌 2

### 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

  - `x`보다 크고 `x`와 비트가 1~2개 다른 수들 중에서 제일 작은 수

예를 들어,

  - `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|  수   |     비트     | 다른 비트의 개수 |
| :---: | :----------: | :--------------: |
|   2   | `000...0010` |                  |
|   3   | `000...0011` |        1         |

  - `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

|  수   |     비트     | 다른 비트의 개수 |
| :---: | :----------: | :--------------: |
|   7   | `000...0111` |                  |
|   8   | `000...1000` |        4         |
|   9   | `000...1001` |        3         |
|  10   | `000...1010` |        3         |
|  11   | `000...1011` |        2         |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

  - 1 ≤ numbers의 길이 ≤ 100,000

  - 0 ≤ numbers의 모든 수 ≤ 10<sup>15</sup>

---

### 입출력 예

| numbers | result |
| :-----: | :----: |
|  [2,7]  | [3,11] |

---

### 입출력 예 설명

#### 입출력 예 #1

문제 예시와 같습니다.

---

### 문제 접근

  - `1LL` = `1`을 `64`비트로 표현한 것

  - LSB가 0인 경우, 1을 더하는 것이 2개 이하로 다른 비트를 가진 수중 제일 작은 수임

  - LSB가 1인 경우, LSB로부터 MSB까지의 비트 중 가장 먼저 등장하는 0값을 가지는 비트를 1로 바꾼 후, 그 바로 윗 비트를 0으로 바꾸면 됨

    ```cpp
    long long temp = 1LL << (digit - 1);
    number = number + (1LL << digit) - temp;
    ```

----

### 다른 사람의 풀이

```cpp
#include <vector>
std::vector<long long> solution(std::vector<long long> numbers) {
    std::vector<long long> answer;
    for (long long number : numbers) {
        long long bit = 1;
        while ((number & bit) > 0) bit <<= 1;
        answer.push_back(number + bit - (bit >> 1));
    }
    return answer;
}
```